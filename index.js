// Libraries
const app = require('express')();
const download = require('download-file');
const fs = require('fs');
const http = require('http');
const https = require('https');
const PDFParser = require('pdf2json');

// Accessibility constants
const DINING_URL = "http://dining.rice.edu/undergraduate-dining/college-serveries/weekly-menus/";
const MENU_DIR = "menu_pdfs";
const SERVERIES = ["Baker", "North", "Seibel", "Sid Rich", "South", "West"];

// Processing constants
const RICE_BLUE = "#16355b";
const WEEKDAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];

// Resources containers
const RESOURCES_DIR = "resources";
const RESOURCES = {};

/**
 * Returns a deep copy of any valid JSON object.
 */
function deepCopy(jsonObj) {
	return JSON.parse(JSON.stringify(jsonObj));
}

/**
 * Sends a GET request to the specified url, and on completion executes the callback provided.
 */
function getHtml(url, successCallback, errorCallback) {
	let getter = null;

	if (url.match(/^https/i))
		getter = https;
	else
		getter = http;

	getter.get(url, response => {
		let html = "";

		response.setEncoding("utf8");
		response.on("data", chunk => html += chunk);
		response.on("end", () => successCallback(html));
	}).on("error", errorCallback);
}

/**
 * Provides a synchronizer for an executer lambda that executes a known number of asynchronous
 * tasks. The executor function is in charge of filling in the provided array with non-null
 * values, and once the array is completely non-null, the callback function is called.
 *
 * executor - Takes in an array that is numAsyncTasks long and is initialized with a null for
 *            each entry. It must divide the work up in such a way that all entries become non-
 *            null at some point in the future.
 *
 * callback - Takes in the array that the executor completely filled with non-null values.
 */
function synchronize(numAsyncTasks, executor, callback) {
	const nnAT = numAsyncTasks;
	const synchronizationArray = new Array(nnAT).map(e => null);
	for (let i = 0; i < nnAT; i++)
		synchronizationArray[i] = null;

	// Pass the reference to the synchronization array to the executor
	executor(synchronizationArray);

	// Check that the array is not entirely null to execute the callback
	let syncTimeoutID = -1;
	const checkFinished = () => {
		let ready = true;
		for (let i = 0; i < nnAT; i++) {
			if (synchronizationArray[i] === null) {
				ready = false;
				break;
			}
		}

		if (ready)
			callback(synchronizationArray);
		else
			syncTimeoutID = setTimeout(checkFinished, 0);
	};

	// Initialize the synchronization check.
	setTimeout(checkFinished, 0);
}

/**
 * Reads the contents of the given directory. It removes any empty directories, and it correctly
 * adds all files in arbitrarily deep file paths.
 */
function flatReadDirectory(dir) {
	const NOT_DIR = "//NOT_DIR//";
	let files = [];

	try {
		const currDir = fs.readdirSync(dir);

		for (let i = 0; i < currDir.length; i++) {
			let subDir = flatReadDirectory(dir + "/" + currDir[i]);

			// This entry is a file
			if (subDir.length == 1 && subDir[0] === NOT_DIR)
				files.push(currDir[i]);

			// This entry is a directory with files
			else if (subDir.length > 0)
				for (let j = 0; j < subDir.length; j++)
					files.push(currDir[i] + "/" + subDir[j]);
		}
	} catch (e) {
		if (e.code == "ENOTDIR")
			files = [NOT_DIR];
		else
			throw e;
	}

	return files;
}

/**
 * Downloads a file from the input URL and saves it to the specified directory. It then executes
 * the appropriate callback if the operation was successful or not.
 *
 * successCallback - Takes in the directory and the filename of the successfully downloaded file
 * errorCallback - Takes in the error object generated by the download library
 */
function downloadFromUrlToDisk(url, targetDir, filename, successCallback, errorCallback) {
	download(url, {directory: targetDir, filename: filename}, e => {
		if (e)
			errorCallback(e);
		else
			successCallback(targetDir, filename);
	});
}

/**
 * Converts the specified PDF file stored on disk to JSON using the pdf2json library. Once it
 * is finished it runs the appropriate callback function depending if there was an error or
 * not.
 *
 * successCallback - Takes in the PDF JSON object as given by the pdf2json library
 * errorCallback - Takes in the error object generated by the pdf2json library, or it takes in
 *                 the error object generate by fs trying to save the JSON file to disk, in
 *                 which case it gets a second argument with the generated JSON object.
 */
function convertPdfToJson(dir, filename, successCallback, errorCallback, saveToDisk, targetDir) {
	const pdfParser = new PDFParser();

	pdfParser.on("pdfParser_dataReady", jsonObj => {
		if (saveToDisk)
			fs.writeFile(targetDir + "/" + filename + ".to.json", JSON.stringify(jsonObj, null, "\t"), "utf8", e => {
				errorCallback(e, jsonObj);
			});
		else
			successCallback(jsonObj);
	});

	pdfParser.on("pdfParser_error", errorCallback);
	pdfParser.loadPDF(dir + "/" + filename);
}

/**
 * Populates the RESOURCES object with the contents of the files in the resources directory.
 *
 * callback - Takes in no arguments and is called whether or not the population of the RESOURCES
 *            object was successful or not.
 */
function er_populateResources(callback) {
	// Ensure that callback is a function
	callback = callback ? callback : () => {};

	try {
		const resourcesDir = flatReadDirectory(RESOURCES_DIR);
		const numFiles = resourcesDir.length;

		synchronize(numFiles, syncArr => {
			for (let i = 0; i < numFiles; i++) {
				const ii = i;

				// Asynchronously read the contents of the current file
				fs.readFile(RESOURCES_DIR + "/" + resourcesDir[ii], (e, data) => {
					if (e)
						throw e;

					RESOURCES[resourcesDir[ii]] = data;
					syncArr[ii] = true;
				});
			}
		}, callback);
	} catch(e) {
		console.error("There was an error reading from the resources directory.\n");
		console.error(e.stack);
		console.error("\n");

		console.log("Populating resources with the error homepage.");

		RESOURCES['index.html'] =
			"<!DOCTYPE html>\n" +
			"<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n" +
			"<h1>There was an internal application error.</h1>\n" +
			"<br>\n" +
			'<p>Please message either ' +
			'<a href="mailto:as100@rice.edu?subject=[Project-ER populateResources err]&cc=jcd7@rice.edu">Andres</a>' +
			' or ' +
			'<a href="mailto:jcd7@rice.edu?subject=[Project-ER populateResources err]&cc=as100@rice.edu">Jade</a> ' +
			'to address the problem as soon as possible.</p>\n' +
			"</html>\n";

		callback();
	}
}

/**
 * Gets the URL to the PDF of the weekly menu for the specified servery from the dining HTML.
 */
function er_extractPdfUrlOf(servery, diningHTML) {
	const regex = new RegExp("<p>(\\r\\n\\s)*<a href=\"([^\"]+)\" target=\"_blank\" rel=\"noopener\">"+buildingName+"<\\/a>");
	const matchesArray = diningHTML.match(regex);
	const matches = matchesArray !== null ? matchesArray.length : 0;

	// 0 = entire match, 1 = first parenthesis, 2 = URL parenthesis
	if (matchesArray !== null && matches === 3)
		return matchesArray[2];
	
	console.error("Unexpected number instances of \""+buildingName+"\" found. Expected 1 but got "+matches+".");
	return "";
}
